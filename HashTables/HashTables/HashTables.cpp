/**
* Hash table in simple terms can be a 2D array in C language. 
* Where we store key-value pair. Example: key: people and value: 20
* so <string, value> combination. (it can be combination of any data types)
* 
* here we are creating a hash function. that depending on size of your array
*  can generate a random number with an algorithm every time you pass a key.
* but passing same key will generate same number every time.
* 
* Now with this unique number generated, we will use it as an index for the array.
* Now for Collisions (which means same index number generated by hash function for 
* different keys ) we will need to use linkedlist. that is why in our node class we
* have : key, value, pair and node* for linked list.
* 
* Now whenever we want to set key , value pair or want to get value based on key 
* we can call set/get functions given below that call hash function for a given key 
* and it tells what index its value can be at.
* 
* Now second task is to iterate over the linked list at given index to see if the 
* given value exist there for get or for set we can end new value to the end of 
* index.
* 
* Where do we use hash table:
* 
* example question: look in 2 arrays if there is a matching value. 
* 
* Now we will create an unordered_map vector or a 2d array where based on each value
* we will use that as key and get index from it to store true as value in vector
* or 2D array. now 2nd array/vector we will look into 2d array or unordered map
* if values exist or not. so thats how we can get result in O(n).
* 
* Another example could be finding duplicates in a list/array
* 
* Example: finding first repeated element in a string, maybe take % with : create array to store
* 
* Example: sumOfTwo(vector, sum), and returns vector of two nums. To create such function use hash
* create key value pair of num, sum-num and create complete hash table (unordered_map). 
* Now next thing when we iterate over unordered map for every item of input vector list,
* put that as key in mapTable , it will give you value and now look for location in 
* mapTable with that value, if anything if present there then it means we found 2nd num
* that generate total sum input to function now return this
* 
* TIP: So hash we generally use when you have to find pairs
*/

#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

class node {
public:
    string key;
    int value;
    node* next;  // because if there is collision, we will start a linked list for that index.

    node(string key, int val):
        key{ key }, value{ val }, next{ nullptr } {}
};

class hashTable {
private:
    static const int SIZE = 7;
    node* dataMap[SIZE];
 
    /** It's purpose is to receive a key and 
    * respond back with an index where we can
    * store key value pair.
    */
    int hash(string key) {
        int hash = 0;

        for (int i = 0; i < key.length(); i++){

            hash = (hash + int(key[i]) * 23) % SIZE;
        }

        return hash;
    }

public:
    void printTable() {
        for (int i = 0; i < SIZE; i++) {
            cout << i << ": " << endl;
            node* tempNode = dataMap[i];

            while (tempNode) {
                cout << tempNode->key << " : " << tempNode->value << endl; 
                tempNode = tempNode->next;
            }
        }
        cout << endl;
    }

    void set(string key, int value) {
        int index = hash(key);
        node* newNode = new node(key, value);
        
        if (dataMap[index] == nullptr) {
            dataMap[index] = newNode;
        }
        else {

            node* tempNode = dataMap[index];
            while (tempNode->next) {
                tempNode = tempNode->next;
            }
            tempNode->next = newNode;
        }
    }

    int get(string key) {
        int index = hash(key);  // here we get the index
        int flag = 0;
        if (dataMap[index] == nullptr) return 0;

        node* tempNode = dataMap[index];

        if (tempNode->key == key) return tempNode->value;

        while (tempNode->next) {
            
            tempNode = tempNode->next;
            if (tempNode->key == key) {
                flag = 1;
                break;
            }
        }
        if(flag) return tempNode->value;   
        return 0;
    }

    bool isItemInCommon(vector<int> vec1, vector<int> vec2) {
        unordered_map<int, bool> myMap;
        for (auto i : vec1) {
            cout << "data is " << i << " ";
            myMap.insert({ i, true });
        }

        cout << endl;
        for (auto i : vec2) {
            if (myMap[i]) return true;
        }

        return false;
    }

    /**
    * TODO: one trick is create a Hash table of incoming vector
    * Now while creating it keep checking for every new value if it is already there
    * if it is then add into a separate vector and return it.
    * 
    * Another way is used unordered_map()
    */
    vector<int> duplicateReturn(const vector<int>& nums) {
    }

    /**
    * How to use unordered maps:
    *       where <int,int> is key and value pair:
    *   unordered_map<int, int>mapTable;
    *   
    *  here [0] is key and 1 is value
    * mapTable[0] = {1};
    * 
    * other way is 
    * mapTable.insert({0,1})
    */
    vector<int> sumOfTwo(vector<int> list, int sum) {

        unordered_map<int, int>mapTable;
        vector<int>retVector;
        for (auto i : list) {
            mapTable.insert({ i, sum - i });
        }

        for (auto i : list) {
            if (mapTable[mapTable[i]]) {
                retVector.emplace_back(mapTable[i]);
                retVector.emplace_back(mapTable[mapTable[i]]);
                return retVector;
            }
        }
    }
};

int main()
{
    hashTable* myHT = new hashTable();
    myHT->printTable();

    
    myHT->set("nails", 100);
    myHT->set("screwDriver", 5);
    myHT->set("screw", 30);
    myHT->set("tiles", 50);
    myHT->set("lumber", 2);
    myHT->set("bolts", 30);
    myHT->printTable();

    cout << "bolt present:  " << myHT->get("bolt") << endl;


    /* See if below two vectors have same number or not?*/
    vector<int> vec1{ 1,3,5,7 };
    vector<int> vec2{ 2,4,6,8 };

    cout << "return of isItemInCommon is : " << myHT->isItemInCommon(vec1, vec2) << endl;

    vector<int> vec{1,2,3,4,5,6,7,8,9};
    vector<int> res;

    res = myHT->sumOfTwo(vec, 8);

    cout << "Sum of two returned : ";
    for (auto i : res) {
        cout << i << " ";
    }

}

